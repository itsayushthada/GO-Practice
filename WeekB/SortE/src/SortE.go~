/*
	Parallel Merge Sort
*/

package main

import(
	"fmt"
	"time"
	"math/rand"
	"testing"
	"sync"
)

func Merge(arr []int, s_idx int, m_idx int, e_idx int){
	/*
	This function takes two arrays and merge them into one array sorted array.
	Two arrays which are passed contigoues in memory.
	First array lies between s_idx and m_idx indices and next array lies between m_idx+1 and
	e_idx indices of the parent array.
	Here instead of arrays slices are used.
	*/

	idx_1 := 0
	idx_2 := 0
	idx_main := s_idx

	temp1 := make([]int, m_idx+1-s_idx)
	temp2 := make([]int, e_idx-m_idx)

	copy(temp1, arr[s_idx:m_idx+1])
	copy(temp2, arr[m_idx+1:e_idx+1])

	for idx_1 < len(temp1) && idx_2 < len(temp2){
		if(temp1[idx_1] < temp2[idx_2]){
			arr[idx_main] = temp1[idx_1]
			idx_1 = idx_1+1
		} else{
			arr[idx_main] = temp2[idx_2]
			idx_2 = idx_2+1
		}
		idx_main = idx_main+1
	}

	if(idx_1 == len(temp1)){
		copy(arr[idx_main:e_idx+1], temp2[idx_2:])
		idx_2 = len(temp2)
	} else{
		copy(arr[idx_main:e_idx+1], temp1[idx_1:])
		idx_1 = len(temp1)
	}
	idx_main = e_idx+1
}

func Split(arr []int, s_idx int, m_idx int, e_idx int){
	/*
	This function splits the array into two sub arrays. It's immplemented with the
	help of slices.
	*/

	go MergeSort(arr, s_idx, m_idx)
	go MergeSort(arr, m_idx+1, e_idx)
}

func MergeSort(arr []int, s_idx int, e_idx int){
	/*
	This function takes the data slice or parent slice and recursively splits into
	slice of half size upto a minimum size ie. 2 and then merge those slices until
	we merge all the children slice.
	*/

	m_idx := int((s_idx + e_idx)/2)
	if(s_idx != m_idx || e_idx != m_idx){
		Split(arr, s_idx, m_idx, e_idx)
		Merge(arr, s_idx, m_idx, e_idx)
	}

}

func BenchmarkFunction(b *testing.B){
	/*
	This function is used to mesure the performance of function after each improvement.
	*/

	size := 1e4
	rand.Seed(time.Now().UnixNano())
	arr := make([]int, uint(size))
	for i:=0 ; i<len(arr) ; i++{
		arr[i] = rand.Intn(100)
	}
	MergeSort(arr, 0, len(arr)-1)
}

func main(){
	/*
	This is a driver functions. It will allow us to encapsulte different function.
	*/

	size := 20
	rand.Seed(time.Now().UnixNano())
	arr := make([]int, uint(size))
	for i:=0 ; i<len(arr) ; i++{
		arr[i] = rand.Intn(100)
	}

	fmt.Printf("\nOriginal Array: %v\n", arr)
	MergeSort(arr, 0, len(arr)-1, &wg)
	fmt.Printf("Sorted Array: %v\n", arr)
}
